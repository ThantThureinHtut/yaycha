================================================================================
                    REAL-TIME UPDATE FEATURE WORKFLOW
                          Yaycha Application
================================================================================

Project: Yaycha (Social Media Platform)
Feature: Real-Time Updates using WebSockets and Broadcasting
Broadcasting Service: Laravel Reverb / Pusher
Frontend Framework: React with Inertia.js
Last Updated: November 29, 2025

================================================================================
                              TABLE OF CONTENTS
================================================================================

1. Architecture Overview
2. Feature Components
3. Event Flow Diagrams
4. Implementation Details
5. Channel Mechanisms
6. Frontend Hook Structure
7. Complete User Journey Examples
8. Error Handling & Guards
9. Performance Optimizations
10. Future Enhancements

================================================================================
1. ARCHITECTURE OVERVIEW
================================================================================

The real-time update system uses a pub/sub (Publish/Subscribe) architecture:

BACKEND (Laravel)
├── Events (ShouldBroadcast)
│   ├── PostCreatedEvent
│   ├── PostViewEvent
│   ├── PostLikeEvent (exists but not actively used yet)
│   └── UserFollowerEvent
├── Controllers (Dispatch Events)
│   ├── PostController
│   ├── ViewController
│   └── FollowController
├── Broadcasting Config
│   ├── Broadcasting Service (Reverb/Pusher)
│   └── Channel Authorization (routes/channels.php)
└── Models (with Events)
    ├── Post
    ├── View
    ├── Like
    └── User

FRONTEND (React)
├── usePostEcho Hook (Subscription Management)
├── Components
│   ├── Home Feed
│   ├── User Dashboard
│   └── Profile Pages
└── State Management (useState)

BROADCAST SERVER
├── Reverb (Laravel's WebSocket Server)
└── Or Pusher (Third-party service)

================================================================================
2. FEATURE COMPONENTS
================================================================================

2.1 REAL-TIME FEATURES IMPLEMENTED:

┌─────────────────────────────────────────────────────────────────────────┐
│ A. POST CREATION (Real-Time Feed Updates)                              │
├─────────────────────────────────────────────────────────────────────────┤
│ When: User creates a new post                                          │
│ Event: PostCreatedEvent                                                │
│ Channels: 'feed' (public), 'user.{userId}' (private)                  │
│ Updates: All users see new post at top of feed instantly               │
│ Data: Full post with user, likes, comments, views, saveds             │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ B. POST VIEWS (Real-Time View Count Updates)                           │
├─────────────────────────────────────────────────────────────────────────┤
│ When: User views a post                                                │
│ Event: PostViewEvent                                                   │
│ Channels: 'feed' (public), 'user.{postOwnerId}' (private)            │
│ Updates: View count updates + view history maintained                 │
│ Data: View record + total view count                                  │
│ Guard: Only count if user hasn't already viewed (prevent duplicates)  │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ C. USER FOLLOWS (Real-Time Follower Updates)                           │
├─────────────────────────────────────────────────────────────────────────┤
│ When: User follows/unfollows another user                              │
│ Event: UserFollowerEvent                                               │
│ Channels: 'follower.{userId}' (private)                               │
│           'following.{followedUserId}' (private)                       │
│ Updates: Follower count increases + follower list updates            │
│ Data: New follower/following user object                              │
│ Guard: Check if not already following before adding to list           │
└─────────────────────────────────────────────────────────────────────────┘

================================================================================
3. EVENT FLOW DIAGRAMS
================================================================================

3.1 POST CREATION FLOW:

User (Frontend)
    ↓
[Form Submit]
    ↓
PostController::post()
    ↓
Post::create() ← Save to DB
    ↓
PostCreatedEvent::dispatch($post)
    ↓
    ├─→ [Broadcast Service (Reverb/Pusher)]
    │       ├─→ 'feed' Channel (Public)
    │       └─→ 'user.{userId}' Channel (Private)
    │
    └─→ [Frontend (React)]
        ├─→ window.Echo.channel('feed').listen('PostCreatedEvent')
        └─→ setPosts(prevPosts => [newPost, ...prevPosts])


3.2 POST VIEW FLOW:

User (Frontend) Views Post
    ↓
ViewController::store()
    ↓
View::create() ← Save to DB
    ↓
PostViewEvent::dispatch($view)
    ↓
    ├─→ [Broadcast Service]
    │       ├─→ 'feed' Channel
    │       └─→ 'user.{postOwnerId}' Channel
    │
    └─→ [Frontend (React)]
        ├─→ Check if user already viewed
        ├─→ If NO: Update view count + add view to history
        └─→ If YES: Do nothing (Guard prevents duplicate)


3.3 USER FOLLOW FLOW:

User A Clicks Follow on User B
    ↓
FollowController::store($userId)
    ↓
Follow::create() ← Save to DB
    ↓
UserFollowerEvent::dispatch($follow)
    ↓
    ├─→ [Broadcast Service]
    │       ├─→ 'follower.{userAId}' Channel (Private)
    │       └─→ 'following.{userBId}' Channel (Private)
    │
    └─→ [Frontend (React)]
        ├─→ User B's profile page listens
        └─→ Followers count increases + new follower added to list

================================================================================
4. IMPLEMENTATION DETAILS
================================================================================

4.1 BACKEND: EVENT DISPATCHING

File: app/Http/Controllers/PostController.php
─────────────────────────────────────────────
    public function post(Request $request)
    {
        $post = Post::create([...]);              // Step 1: Save to DB
        PostCreatedEvent::dispatch($post);        // Step 2: Broadcast Event
        return Redirect::route('home');
    }

Key Points:
- PostCreatedEvent implements ShouldBroadcast interface
- Event is queued (async) - doesn't block user response
- Works with or without Queue Worker (depending on config)


4.2 BACKEND: EVENT BROADCASTING CONFIG

File: app/Events/PostCreatedEvent.php
─────────────────────────────────────────────
    public function broadcastOn(): array
    {
        return [
            new Channel('feed'),                    // Public Channel
            new PrivateChannel('user.' . $this->post->user_id)  // Private
        ];
    }

    public function broadcastWith(): array
    {
        $this->post->load([                         // Load relationships
            'user:id,username,email,bluemark,avatar_url',
            'likes',
            'comments',
            'views',
            'saveds'
        ]);

        $this->post->loadCount([                    // Load counts
            'likes',
            'views',
            'comments'
        ]);

        return ['post' => $this->post->toArray()];  // Convert to array
    }

Why loadCount & load?
- Worker/Queue processes events separately from HTTP request
- Must explicitly load relationships (not available from original object)
- Must convert to array to avoid serialization errors
- Frontend needs complete object with all data


4.3 BACKEND: CHANNEL AUTHORIZATION

File: routes/channels.php
─────────────────────────────────────────────
    Broadcast::channel('user.{id}', function ($user, $id) {
        return (int) $user->id === (int) $id;      // Only user can listen
    });

    Broadcast::channel('follower.{id}', function ($user, $id) {
        return (int) $user->id === (int) $id;      // Only target user
    });

Authorization Rules:
- Public channels: Anyone can listen ('feed', 'post.likes', etc.)
- Private channels: Only authorized users
  - user.{id}: Only user with matching ID
  - follower.{id}: Only the follower getting the notification
  - following.{id}: Only the user being followed


4.4 BROADCASTING SERVICE CONFIG

File: config/broadcasting.php
─────────────────────────────────────────────
Current Setup: Laravel Reverb (Default)

Options Available:
    1. Reverb (Laravel's built-in WebSocket server)
       - Free, built-in
       - Local development friendly
       - Needs separate process

    2. Pusher (Third-party service)
       - Reliable production option
       - Hosted solution
       - Paid service

Current Config:
    'default' => env('BROADCAST_CONNECTION', 'null')

To enable, set in .env:
    BROADCAST_CONNECTION=reverb
    Or: BROADCAST_CONNECTION=pusher (with API keys)


================================================================================
5. CHANNEL MECHANISMS
================================================================================

5.1 PUBLIC CHANNELS (Unauthenticated Access)

Channel Name: 'feed'
Purpose: Broadcast new posts to ALL users
Authorization: NONE (anyone can listen)
Events: PostCreatedEvent, PostViewEvent
Usage:
    window.Echo.channel('feed')
        .listen('PostCreatedEvent', (e) => { ... })

Characteristics:
- Unlimited subscribers
- No authentication check
- Good for global feeds


5.2 PRIVATE CHANNELS (Authentication Required)

Pattern: 'user.{id}'
Authorization: Only user with ID === channel ID
Events: PostCreatedEvent, PostViewEvent
Usage:
    window.Echo.private('user.' + userId)
        .listen('PostCreatedEvent', (e) => { ... })

Pattern: 'follower.{id}' & 'following.{id}'
Authorization: Specific follower/following relationship
Events: UserFollowerEvent
Usage:
    window.Echo.private('follower.' + userId)
        .listen('UserFollowerEvent', (e) => { ... })

Characteristics:
- Encrypted channels
- Server-side authorization
- Verified Laravel auth session


5.3 CHANNEL NAMING CONVENTIONS

Format: {resource}.{identifier}
Examples:
    'feed'                          - Main feed (public)
    'user.123'                      - User 123's dashboard (private)
    'follower.123'                  - User 123 as follower (private)
    'following.123'                 - User 123 as following (private)
    'post.456'                      - Post 456 updates (not yet used)

Hierarchy:
    Global Level: 'feed'
    User Level: 'user.{id}'
    Relationship Level: 'follower.{id}', 'following.{id}'
    Resource Level: 'post.{id}' (reserved for future)

================================================================================
6. FRONTEND HOOK STRUCTURE
================================================================================

File: resources/js/Components/Hooks/usePostEcho.js
─────────────────────────────────────────────────

6.1 HOOK SIGNATURE:

    export default function usePostEcho(
        setPosts,
        filterUserId = null,
        setUser = null
    )

Parameters:
    - setPosts: State setter for posts array (REQUIRED)
    - filterUserId: If viewing specific user dashboard (OPTIONAL)
    - setUser: State setter for current user object (OPTIONAL)


6.2 CHANNEL SELECTION LOGIC:

    if (filterUserId) {
        // User Dashboard: Private channels
        channelName = `user.${filterUserId}`
        followChannelName = `following.${filterUserId}`
        channel = window.Echo.private(channelName)
        followChannel = window.Echo.private(followChannelName)
    } else {
        // Home Feed: Public + Private mix
        channelName = "feed"                          // Public
        followChannelName = `follower.${auth.user.id}` // Private
        channel = window.Echo.channel(channelName)
        followChannel = window.Echo.private(followChannelName)
    }

Two Modes:
    1. HOME FEED: filterUserId = null
       - Public 'feed' channel for new posts
       - Private 'follower.{myId}' for my follower updates

    2. USER DASHBOARD: filterUserId = specificUserId
       - Private 'user.{specificUserId}' for their posts
       - Private 'following.{specificUserId}' for their followers


6.3 EVENT LISTENERS:

A. PostCreatedEvent Listener
─────────────────────────────
    channel.listen("PostCreatedEvent", (e) => {
        setPosts((prevPosts) => {
            // GUARD: Check if post already exists (prevent duplicates)
            const alreadyExists = prevPosts.some(
                (post) => post.id === e.post.id
            );
            if (alreadyExists) {
                return prevPosts;  // Stop! Don't add it again.
            }
            return [e.post, ...prevPosts];  // Add to top
        });
    });

Why the Guard?
- React Strict Mode runs effects twice in development
- Multiple re-renders could trigger listener multiple times
- Prevents duplicate posts in feed


B. PostViewEvent Listener
──────────────────────────
    channel.listen("PostViewEvent", (e) => {
        setPosts((prevPosts) => {
            return prevPosts.map((post) => {
                if (post.id === e.view.post_id) {
                    const currentView = post.views || []
                    const alreadyViewed = currentView.some(
                        (viewItem) => viewItem.user_id === e.view.user_id
                    );

                    if (!alreadyViewed) {
                        return {
                            ...post,
                            views: [...post.views, e.view],
                            views_count: e.view_count,
                            views_count_formatted: formatNumber(e.view_count)
                        };
                    }
                }
                return post;
            });
        });
    });

Why Check Existing Views?
- Prevent counting same view twice
- Maintain accurate view history
- Avoid duplicate entries in views array


C. UserFollowerEvent Listener
──────────────────────────────
    followChannel.listen("UserFollowerEvent", (e) => {
        setUser((prevUser) => {
            if (!prevUser) return;  // Guard: User not loaded yet

            const currentFollow = prevUser.followers || []
            const alreadyFollow = currentFollow.some(
                (follow) => follow.id === e.new_follower.id
            )

            if (alreadyFollow) {
                return prevUser;    // Already follows, no change
            }

            return {
                ...prevUser,
                followers: [...prevUser.followers, e.new_follower],
                followers_count: prevUser.followers_count + 1,
                followers_count_formatted: formatNumber(
                    prevUser.followers_count + 1
                )
            }
        });
    });

Why Check Existing Followers?
- Follow/Unfollow: Same event handles both
- Guard prevents duplicate follower entries
- Maintains accurate follower count


6.4 CLEANUP FUNCTION:

    return () => {
        window.Echo.leave(channelName);
        window.Echo.leave(followChannelName);
    };

When Does This Run?
- Component unmounts
- Dependencies change ([ ] dependency array)

Why Important?
- Removes event listeners
- Closes WebSocket connections
- Frees memory
- Prevents memory leaks


6.5 FORMATTING UTILITY:

    const formatNumber = (num) => {
        return new Intl.NumberFormat("en-US", {
            notation: "compact",
            compactDisplay: "short",
        }).format(num);
    };

Examples:
    1000        → "1K"
    1500        → "1.5K"
    1000000     → "1M"
    1500000     → "1.5M"

Used for:
    - views_count_formatted
    - followers_count_formatted
    - likes_count_formatted (future)

================================================================================
7. COMPLETE USER JOURNEY EXAMPLES
================================================================================

7.1 SCENARIO 1: Home Feed - New Post Creation

Timeline:
─────────

T=0s  User A visits /home
      ├─ Loads initial posts from DB
      ├─ usePostEcho hook initializes
      ├─ Subscribes to:
      │  ├─ Public 'feed' channel
      │  └─ Private 'follower.{userAId}' channel
      └─ Ready for real-time updates

T=5s  User B creates a post via /post/post_create
      ├─ Backend: PostController::post()
      ├─ DB: Post saved with id=42, user_id=userB.id
      ├─ Event: PostCreatedEvent($post) dispatched
      ├─ Broadcast to:
      │  ├─ Public 'feed' channel → ALL users
      │  └─ Private 'user.{userBId}' → Only User B
      └─ Broadcast includes complete post data

T=5.1s [User A's Browser]
       ├─ Receives 'PostCreatedEvent' on 'feed'
       ├─ Guard: Check if post.id=42 already exists (NO)
       ├─ Frontend: setPosts([newPost, ...oldPosts])
       ├─ React re-renders feed
       └─ New post appears at TOP instantly!

T=5.1s [User B's Browser]
       ├─ Receives 'PostCreatedEvent' on 'user.{userBId}'
       ├─ Guard: Check if post.id=42 already exists (NO)
       ├─ Frontend: setPosts([newPost, ...oldPosts])
       ├─ React re-renders
       └─ Sees own post in feed + dashboard

Result: ALL online users see new post immediately


7.2 SCENARIO 2: User Dashboard - View Count Update

Timeline:
─────────

T=0s  User C visits User B's profile (/acccount/profile.php?id=userB)
      ├─ usePostEcho initialized with filterUserId=userB
      ├─ Loads User B's posts from DB
      ├─ Subscribes to:
      │  ├─ Private 'user.{userBId}' → User B's posts
      │  └─ Private 'following.{userBId}' → User B's followers
      └─ Ready for updates

T=10s User A views one of User B's posts
      ├─ Frontend: Calls ViewController::store()
      ├─ DB: View record created (post_id=42, user_id=userA)
      ├─ Event: PostViewEvent($view) dispatched
      ├─ Broadcast to:
      │  ├─ Public 'feed' → ALL users
      │  └─ Private 'user.{userBId}' → Only User B
      └─ Includes view count: 15

T=10.1s [User B's Browser - If viewing own dashboard]
        ├─ Receives 'PostViewEvent' on 'user.{userBId}'
        ├─ Finds post with id=42
        ├─ Guard: Check if userA already viewed (NO)
        ├─ Updates:
        │  ├─ views array: [..., new_view_record]
        │  ├─ views_count: 15
        │  └─ views_count_formatted: "15"
        ├─ React re-renders
        └─ View count shows "15" with new viewer

T=10.1s [User C's Browser - If on User B's profile]
        ├─ Receives 'PostViewEvent' on 'user.{userBId}'
        ├─ Same update as User B
        └─ Sees view count increase to 15

Result: View count updates LIVE for all viewing that user's posts


7.3 SCENARIO 3: Profile Follow Action

Timeline:
─────────

T=0s  User A visits User B's profile
      ├─ usePostEcho with filterUserId=userB
      ├─ Subscribes to 'following.{userBId}'
      ├─ Loads User B's data including followers
      └─ Sees follower count: 100

T=5s  User C clicks "Follow" on User B's profile
      ├─ Frontend: POST /acccount/follow/userB
      ├─ Backend: FollowController::store($userBId)
      ├─ DB: Follow record created (user_id=userB, follower_id=userC)
      ├─ Check: Is User C already following User B? NO
      ├─ Event: UserFollowerEvent($follow) dispatched
      ├─ Broadcast to:
      │  ├─ Private 'follower.{userCId}' → User C (who followed)
      │  └─ Private 'following.{userBId}' → User B (who was followed)
      └─ Includes: new_follower data + new_following data

T=5.1s [User B's Browser - If viewing own profile]
       ├─ Receives 'UserFollowerEvent' on 'following.{userBId}'
       ├─ Guard: Check if User C already in followers (NO)
       ├─ Updates:
       │  ├─ followers array: [..., userC]
       │  ├─ followers_count: 101
       │  └─ followers_count_formatted: "101"
       ├─ React re-renders
       └─ Sees new follower "User C" appear in list!

T=5.1s [User A's Browser - If viewing User B's profile]
       ├─ Receives 'UserFollowerEvent' on 'following.{userBId}'
       ├─ Same update as User B
       └─ Sees follower count: 101 with new follower

T=5.1s [User C's Browser - After clicking Follow]
       ├─ Frontend already updated optimistically (before broadcast)
       ├─ Broadcast confirms the action
       └─ Data is consistent

Result: User B's follower count + list updates LIVE for all viewers


7.4 SCENARIO 4: Multiple Users Interacting

Timeline: Real-world chaos with 10 users online
───────────────────────────────────────────────

Users A, B, C, D, E, F, G, H, I, J all on /home

T=0-30s Sequential posts created by different users:
        User B creates post 1 → BROADCAST 'feed'
        User D creates post 2 → BROADCAST 'feed'
        User F creates post 3 → BROADCAST 'feed'
        User H creates post 4 → BROADCAST 'feed'

        [All users on home see posts appear in real-time]
        [Feed order: 4, 3, 2, 1, ...oldPosts]

T=30s   Multiple views happening simultaneously:
        User A views post 4 → BROADCAST 'feed' + 'user.H'
        User B views post 4 → BROADCAST 'feed' + 'user.H'
        User C views post 3 → BROADCAST 'feed' + 'user.F'

        [Home users see view counts increase live]
        [User H/F (if online) see their post views increase]

T=60s   User G follows User E:
        ├─ User E sees follower count +1 (if viewing own profile)
        ├─ User G sees new following added (if viewing profile)
        └─ Other users see no change (not subscribed to their channels)

Result: System handles concurrent real-time updates seamlessly


================================================================================
8. ERROR HANDLING & GUARDS
================================================================================

8.1 DUPLICATE POST GUARD

Problem:
- React Strict Mode runs effects twice in development
- Multiple renders could add same post twice
- Browser history/cache issues

Solution in Hook:
    const alreadyExists = prevPosts.some(
        (post) => post.id === e.post.id
    );
    if (alreadyExists) {
        return prevPosts;  // Ignore duplicate
    }

Implementation:
- Checks post.id against all existing posts
- Returns unmodified state if duplicate found
- Only adds post if it's truly new


8.2 DUPLICATE VIEW GUARD

Problem:
- Same user might view post multiple times
- Should not count as multiple views

Solution in Hook:
    const alreadyViewed = currentView.some(
        (viewItem) => viewItem.user_id === e.view.user_id
    );
    if (!alreadyViewed) {
        // Add to views
        return { ...post, views: [...post.views, e.view] };
    } else {
        return post;  // Already viewed, no change
    }

Implementation:
- Checks if user_id already in views array
- Only increments count if NEW viewer
- Maintains accurate view history


8.3 DUPLICATE FOLLOWER GUARD

Problem:
- Same user might be added to followers twice
- Race conditions in follow/unfollow

Solution in Hook:
    const alreadyFollow = currentFollow.some(
        (follow) => follow.id === e.new_follower.id
    )
    if(alreadyFollow) {
        return prevUser;  // Already in list
    }

Implementation:
- Checks if follower.id already exists
- Only adds if truly new follower
- Prevents duplicate follower entries


8.4 NULL/UNDEFINED GUARDS

Problem:
- Component might not be fully initialized
- Data might not be loaded yet

Solution in Hook:
    setUser((prevUser) => {
        if (!prevUser) return;  // Guard: Skip if user not loaded
        // ... rest of logic
    });

Use Cases:
- User data loading asynchronously
- Component mounting/unmounting
- Missing data from server


8.5 WEBSOCKET CONNECTION ERROR

Current Handling: Automatic by Laravel Echo
- Reconnection attempts: Built-in
- Exponential backoff: Implemented
- Fallback: Graceful degradation

Future Improvement:
- Add error callback to Echo listeners
- Display offline indicator to user
- Queue updates for when connection restored


================================================================================
9. PERFORMANCE OPTIMIZATIONS
================================================================================

9.1 RELATIONSHIP LOADING IN EVENTS

In PostCreatedEvent.php:
    public function broadcastWith(): array
    {
        $this->post->load([
            'user:id,username,email,bluemark,avatar_url',
            'likes',
            'comments',
            'views',
            'saveds'
        ]);

Benefits:
- Specific columns only (user: clause)
- Not loading entire user table
- Reduces memory usage
- Faster broadcast payload


9.2 COUNT OPTIMIZATION

    $this->post->loadCount(['likes', 'views', 'comments']);

Benefits:
- Separate query for counts (not full relationship)
- Prevents N+1 query problems
- Faster than loading full records
- Essential for large datasets


9.3 ARRAY CONVERSION

    return ['post' => $this->post->toArray()];

Benefits:
- Prevents serialization errors
- JSON-safe payload
- Smaller transmitted data
- No reference objects


9.4 FORMATTED NUMBERS IN FRONTEND

    const formatNumber = (num) => {
        return new Intl.NumberFormat("en-US", {
            notation: "compact",
            compactDisplay: "short",
        }).format(num);
    };

Benefits:
- Display: "1M" instead of "1000000"
- Visual appeal
- Saves screen space
- Computed on frontend (no backend work)


9.5 CHANNEL SPECIFICITY

Different channels for different contexts:
    'feed'                      → All users (many subscribers)
    'user.{id}'                 → Single user (few subscribers)
    'follower.{id}'             → Single user (few subscribers)

Benefits:
- Reduces unnecessary broadcasts
- Targets only interested users
- Saves bandwidth
- Improves real-time responsiveness


9.6 STATE IMMUTABILITY

    setPosts((prevPosts) => {
        return [newPost, ...prevPosts];  // New array created
    });

Benefits:
- React can detect changes
- Proper re-render triggering
- Prevents mutation bugs
- Better performance with React DevTools


9.7 CONDITIONAL LOGIC

Only dispatch events when needed:

In PostController:
    PostCreatedEvent::dispatch($post);  // Always broadcast

In FollowController:
    broadcast(new UserFollowerEvent($follow))->toOthers();

toOthers() Benefits:
- Doesn't send to the person who initiated action
- They already have optimistic update
- Saves bandwidth
- Prevents double updates


================================================================================
10. FUTURE ENHANCEMENTS
================================================================================

10.1 LIKE EVENTS (PostLikeEvent exists but unused)

File: app/Events/PostLikeEvent.php

Implementation Steps:
1. Create LikeController or add to PostController
2. When user likes: Like::create()
3. Dispatch: PostLikeEvent::dispatch($like)
4. Add listener in usePostEcho hook:
    channel.listen("PostLikeEvent", (e) => {
        // Update likes_count and likes array
    })

Channel Strategy:
    'feed' → All users
    'user.{postOwnerId}' → Post owner


10.2 COMMENT EVENTS (Not yet implemented)

New Event Needed: PostCommentEvent

Implementation Steps:
1. Create app/Events/PostCommentEvent.php
2. When user comments: Comment::create()
3. Dispatch: PostCommentEvent::dispatch($comment)
4. Add listener in usePostEcho hook
5. Subscribe to 'post.{postId}' channel

Channel Strategy:
    'feed' → All users
    'user.{postOwnerId}' → Post owner
    'post.{postId}' → People viewing that post


10.3 NOTIFICATION SYSTEM

Future Architecture:
    User A follows User B
    → UserFollowerEvent broadcasts
    → Notification::create() for User B
    → New event: NotificationCreatedEvent
    → Real-time notification bell with count

Channels:
    'notification.{userId}' → User's personal notifications


10.4 LIVE TYPING INDICATOR

Use Case: Show "User X is typing..." in comments

Implementation:
1. Create TypingEvent
2. Broadcast when user starts typing
3. Stop broadcast after 3 seconds of inactivity
4. Frontend listens and displays indicator

Channels:
    'post.{postId}.typing' → Typing users for that post


10.5 OFFLINE AWARENESS

Current: No offline detection

Future:
1. Track user presence with Presence Channels
2. Show "Online" / "Last seen..." status
3. Indicate when User B comes online while User A is viewing their profile

Implementation:
    window.Echo.join('profile.' + userId)
        .here((users) => { ... })
        .joining((user) => { ... })
        .leaving((user) => { ... })


10.6 QUERY OPTIMIZATION

Current: Full relationship loads

Improvement:
1. Implement GraphQL for selective field loading
2. Only send needed data per request
3. Client specifies exactly what fields needed

Example:
    // Current: Loads everything
    'user:id,username,email,bluemark,avatar_url',
    'likes',
    'comments',
    'views',
    'saveds'

    // Future GraphQL: Load selectively
    query GetPost($id: ID!) {
        post(id: $id) {
            id
            title
            user { username avatar_url }
            likes_count
            views_count
        }
    }


10.7 ANALYTICS & LOGGING

Not Currently Tracked:
- When events are broadcasted
- How many users received updates
- Failed broadcasts
- Lag/latency metrics

Future Implementation:
1. Log all events: PostCreatedEvent fired at T=5.1s
2. Track: Event → Broadcast → Frontend received
3. Measure latency: < 100ms optimal
4. Alert on failures: Event broadcast failed, check Reverb


================================================================================
                            CONFIGURATION NOTES
================================================================================

ENVIRONMENT SETUP (.env)

Enable Broadcasting:
    BROADCAST_CONNECTION=reverb

Or with Pusher:
    BROADCAST_CONNECTION=pusher
    PUSHER_APP_ID=your_app_id
    PUSHER_APP_KEY=your_app_key
    PUSHER_APP_SECRET=your_app_secret
    PUSHER_APP_CLUSTER=mt1

Reverb Configuration:
    REVERB_APP_ID=your_app_id
    REVERB_APP_KEY=your_app_key
    REVERB_APP_SECRET=your_app_secret
    REVERB_HOST=127.0.0.1
    REVERB_PORT=8080
    REVERB_SCHEME=http


QUEUE SETUP

Broadcasting uses Laravel Queue for async event processing.

Options:
    1. Sync (Immediate) - Good for dev, bad for production
    2. Database - Good for dev, okay for production
    3. Redis - Best for production
    4. SQS - AWS managed service

Current Likely: Sync or Database

Set in .env:
    QUEUE_CONNECTION=database
    Or: QUEUE_CONNECTION=redis


TESTING IN DEVELOPMENT

1. Enable Reverb:
   php artisan reverb:start

2. Or use Pusher:
   Set BROADCAST_CONNECTION=pusher in .env

3. Check broadcasting:
   php artisan make:event TestBroadcast
   fire event and watch WebSocket traffic

4. Chrome DevTools:
   Network tab → WS (WebSocket) filter
   Watch for real-time message exchanges


================================================================================
                               TROUBLESHOOTING
================================================================================

Issue: Real-time updates not showing
Solution:
1. Check BROADCAST_CONNECTION in .env
2. Ensure Reverb/Pusher is running
3. Check browser console for errors
4. Verify channels.php authorization rules
5. Check event listeners in usePostEcho

Issue: Duplicate posts in feed
Solution:
1. Already handled with guard checks
2. If still happening: Clear browser cache
3. Check React key props in rendered lists

Issue: View count not updating
Solution:
1. Check ViewController is dispatching PostViewEvent
2. Verify View model is being created
3. Check hook is listening to PostViewEvent

Issue: Follow count not updating
Solution:
1. Check FollowController dispatches UserFollowerEvent
2. Verify Follow model relationship
3. Check hook's setUser is being passed and called


================================================================================
                                END OF DOCUMENT
================================================================================

Author: Yaycha Development Team
Date: November 29, 2025
Version: 1.0 (Initial Documentation)

This workflow document provides comprehensive coverage of the real-time
update feature implementation including architecture, components, event flows,
frontend hooks, and future enhancements.

For code updates, refer to source files:
- Backend: app/Events/, app/Http/Controllers/
- Frontend: resources/js/Components/Hooks/usePostEcho.js
- Config: routes/channels.php, config/broadcasting.php

================================================================================
